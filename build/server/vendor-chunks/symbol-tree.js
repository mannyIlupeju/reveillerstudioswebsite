"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/symbol-tree";
exports.ids = ["vendor-chunks/symbol-tree"];
exports.modules = {

/***/ "(ssr)/./node_modules/symbol-tree/lib/SymbolTree.js":
/*!****************************************************!*\
  !*** ./node_modules/symbol-tree/lib/SymbolTree.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/**\n * @module symbol-tree\n * @author Joris van der Wel <joris@jorisvanderwel.com>\n */\n\nconst SymbolTreeNode = __webpack_require__(/*! ./SymbolTreeNode */ \"(ssr)/./node_modules/symbol-tree/lib/SymbolTreeNode.js\");\nconst TreePosition = __webpack_require__(/*! ./TreePosition */ \"(ssr)/./node_modules/symbol-tree/lib/TreePosition.js\");\nconst TreeIterator = __webpack_require__(/*! ./TreeIterator */ \"(ssr)/./node_modules/symbol-tree/lib/TreeIterator.js\");\n\nfunction returnTrue() {\n        return true;\n}\n\nfunction reverseArrayIndex(array, reverseIndex) {\n        return array[array.length - 1 - reverseIndex]; // no need to check `index >= 0`\n}\n\nclass SymbolTree {\n\n        /**\n         * @constructor\n         * @alias module:symbol-tree\n         * @param {string} [description='SymbolTree data'] Description used for the Symbol\n         */\n        constructor(description) {\n                this.symbol = Symbol(description || 'SymbolTree data');\n        }\n\n        /**\n         * You can use this function to (optionally) initialize an object right after its creation,\n         * to take advantage of V8's fast properties. Also useful if you would like to\n         * freeze your object.\n         *\n         * `O(1)`\n         *\n         * @method\n         * @alias module:symbol-tree#initialize\n         * @param {Object} object\n         * @return {Object} object\n         */\n        initialize(object) {\n                this._node(object);\n\n                return object;\n        }\n\n        _node(object) {\n                if (!object) {\n                        return null;\n                }\n\n                const node = object[this.symbol];\n\n                if (node) {\n                        return node;\n                }\n\n                return (object[this.symbol] = new SymbolTreeNode());\n        }\n\n        /**\n         * Returns `true` if the object has any children. Otherwise it returns `false`.\n         *\n         * * `O(1)`\n         *\n         * @method hasChildren\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Boolean}\n         */\n        hasChildren(object) {\n                return this._node(object).hasChildren;\n        }\n\n        /**\n         * Returns the first child of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method firstChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        firstChild(object) {\n                return this._node(object).firstChild;\n        }\n\n        /**\n         * Returns the last child of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method lastChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        lastChild(object) {\n                return this._node(object).lastChild;\n        }\n\n        /**\n         * Returns the previous sibling of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method previousSibling\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        previousSibling(object) {\n                return this._node(object).previousSibling;\n        }\n\n        /**\n         * Returns the next sibling of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method nextSibling\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        nextSibling(object) {\n                return this._node(object).nextSibling;\n        }\n\n        /**\n         * Return the parent of the given object.\n         *\n         * * `O(1)`\n         *\n         * @method parent\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        parent(object) {\n                return this._node(object).parent;\n        }\n\n        /**\n         * Find the inclusive descendant that is last in tree order of the given object.\n         *\n         * * `O(n)` (worst case) where `n` is the depth of the subtree of `object`\n         *\n         * @method lastInclusiveDescendant\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object}\n         */\n        lastInclusiveDescendant(object) {\n                let lastChild;\n                let current = object;\n\n                while ((lastChild = this._node(current).lastChild)) {\n                        current = lastChild;\n                }\n\n                return current;\n        }\n\n        /**\n         * Find the preceding object (A) of the given object (B).\n         * An object A is preceding an object B if A and B are in the same tree\n         * and A comes before B in tree order.\n         *\n         * * `O(n)` (worst case)\n         * * `O(1)` (amortized when walking the entire tree)\n         *\n         * @method preceding\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @param {Object} [options]\n         * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n         *        of the return value (or else null is returned). This check _assumes_\n         *        that `root` is also an inclusive ancestor of the given `object`\n         * @return {?Object}\n         */\n        preceding(object, options) {\n                const treeRoot = options && options.root;\n\n                if (object === treeRoot) {\n                        return null;\n                }\n\n                const previousSibling = this._node(object).previousSibling;\n\n                if (previousSibling) {\n                        return this.lastInclusiveDescendant(previousSibling);\n                }\n\n                // if there is no previous sibling return the parent (might be null)\n                return this._node(object).parent;\n        }\n\n        /**\n         * Find the following object (A) of the given object (B).\n         * An object A is following an object B if A and B are in the same tree\n         * and A comes after B in tree order.\n         *\n         * * `O(n)` (worst case) where `n` is the amount of objects in the entire tree\n         * * `O(1)` (amortized when walking the entire tree)\n         *\n         * @method following\n         * @memberOf module:symbol-tree#\n         * @param {!Object} object\n         * @param {Object} [options]\n         * @param {Object} [options.root] If set, `root` must be an inclusive ancestor\n         *        of the return value (or else null is returned). This check _assumes_\n         *        that `root` is also an inclusive ancestor of the given `object`\n         * @param {Boolean} [options.skipChildren=false] If set, ignore the children of `object`\n         * @return {?Object}\n         */\n        following(object, options) {\n                const treeRoot = options && options.root;\n                const skipChildren = options && options.skipChildren;\n\n                const firstChild = !skipChildren && this._node(object).firstChild;\n\n                if (firstChild) {\n                        return firstChild;\n                }\n\n                let current = object;\n\n                do {\n                        if (current === treeRoot) {\n                                return null;\n                        }\n\n                        const nextSibling = this._node(current).nextSibling;\n\n                        if (nextSibling) {\n                                return nextSibling;\n                        }\n\n                        current = this._node(current).parent;\n                } while (current);\n\n                return null;\n        }\n\n        /**\n         * Append all children of the given object to an array.\n         *\n         * * `O(n)` where `n` is the amount of children of the given `parent`\n         *\n         * @method childrenToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */\n        childrenToArray(parent, options) {\n                const array   = (options && options.array) || [];\n                const filter  = (options && options.filter) || returnTrue;\n                const thisArg = (options && options.thisArg) || undefined;\n\n                const parentNode = this._node(parent);\n                let object = parentNode.firstChild;\n                let index = 0;\n\n                while (object) {\n                        const node = this._node(object);\n                        node.setCachedIndex(parentNode, index);\n\n                        if (filter.call(thisArg, object)) {\n                                array.push(object);\n                        }\n\n                        object = node.nextSibling;\n                        ++index;\n                }\n\n                return array;\n        }\n\n        /**\n         * Append all inclusive ancestors of the given object to an array.\n         *\n         * * `O(n)` where `n` is the amount of ancestors of the given `object`\n         *\n         * @method ancestorsToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */\n        ancestorsToArray(object, options) {\n                const array   = (options && options.array) || [];\n                const filter  = (options && options.filter) || returnTrue;\n                const thisArg = (options && options.thisArg) || undefined;\n\n                let ancestor = object;\n\n                while (ancestor) {\n                        if (filter.call(thisArg, ancestor)) {\n                                array.push(ancestor);\n                        }\n                        ancestor = this._node(ancestor).parent;\n                }\n\n                return array;\n        }\n\n        /**\n         * Append all descendants of the given object to an array (in tree order).\n         *\n         * * `O(n)` where `n` is the amount of objects in the sub-tree of the given `object`\n         *\n         * @method treeToArray\n         * @memberOf module:symbol-tree#\n         * @param {Object} root\n         * @param {Object} [options]\n         * @param {Object[]} [options.array=[]]\n         * @param {Function} [options.filter] Function to test each object before it is added to the array.\n         *                            Invoked with arguments (object). Should return `true` if an object\n         *                            is to be included.\n         * @param {*} [options.thisArg] Value to use as `this` when executing `filter`.\n         * @return {Object[]}\n         */\n        treeToArray(root, options) {\n                const array   = (options && options.array) || [];\n                const filter  = (options && options.filter) || returnTrue;\n                const thisArg = (options && options.thisArg) || undefined;\n\n                let object = root;\n\n                while (object) {\n                        if (filter.call(thisArg, object)) {\n                                array.push(object);\n                        }\n                        object = this.following(object, {root: root});\n                }\n\n                return array;\n        }\n\n        /**\n         * Iterate over all children of the given object\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method childrenIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @param {Object} [options]\n         * @param {Boolean} [options.reverse=false]\n         * @return {Object} An iterable iterator (ES6)\n         */\n        childrenIterator(parent, options) {\n                const reverse = options && options.reverse;\n                const parentNode = this._node(parent);\n\n                return new TreeIterator(\n                        this,\n                        parent,\n                        reverse ? parentNode.lastChild : parentNode.firstChild,\n                        reverse ? TreeIterator.PREV : TreeIterator.NEXT\n                );\n        }\n\n        /**\n         * Iterate over all the previous siblings of the given object. (in reverse tree order)\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method previousSiblingsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */\n        previousSiblingsIterator(object) {\n                return new TreeIterator(\n                        this,\n                        object,\n                        this._node(object).previousSibling,\n                        TreeIterator.PREV\n                );\n        }\n\n        /**\n         * Iterate over all the next siblings of the given object. (in tree order)\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method nextSiblingsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */\n        nextSiblingsIterator(object) {\n                return new TreeIterator(\n                        this,\n                        object,\n                        this._node(object).nextSibling,\n                        TreeIterator.NEXT\n                );\n        }\n\n        /**\n         * Iterate over all inclusive ancestors of the given object\n         *\n         * * `O(1)` for a single iteration\n         *\n         * @method ancestorsIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} object\n         * @return {Object} An iterable iterator (ES6)\n         */\n        ancestorsIterator(object) {\n                return new TreeIterator(\n                        this,\n                        object,\n                        object,\n                        TreeIterator.PARENT\n                );\n        }\n\n        /**\n         * Iterate over all descendants of the given object (in tree order).\n         *\n         * Where `n` is the amount of objects in the sub-tree of the given `root`:\n         *\n         * * `O(n)` (worst case for a single iteration)\n         * * `O(n)` (amortized, when completing the iterator)\n         *\n         * @method treeIterator\n         * @memberOf module:symbol-tree#\n         * @param {Object} root\n         * @param {Object} options\n         * @param {Boolean} [options.reverse=false]\n         * @return {Object} An iterable iterator (ES6)\n         */\n        treeIterator(root, options) {\n                const reverse = options && options.reverse;\n\n                return new TreeIterator(\n                        this,\n                        root,\n                        reverse ? this.lastInclusiveDescendant(root) : root,\n                        reverse ? TreeIterator.PRECEDING : TreeIterator.FOLLOWING\n                );\n        }\n\n        /**\n         * Find the index of the given object (the number of preceding siblings).\n         *\n         * * `O(n)` where `n` is the amount of preceding siblings\n         * * `O(1)` (amortized, if the tree is not modified)\n         *\n         * @method index\n         * @memberOf module:symbol-tree#\n         * @param {Object} child\n         * @return {Number} The number of preceding siblings, or -1 if the object has no parent\n         */\n        index(child) {\n                const childNode = this._node(child);\n                const parentNode = this._node(childNode.parent);\n\n                if (!parentNode) {\n                        // In principal, you could also find out the number of preceding siblings\n                        // for objects that do not have a parent. This method limits itself only to\n                        // objects that have a parent because that lets us optimize more.\n                        return -1;\n                }\n\n                let currentIndex = childNode.getCachedIndex(parentNode);\n\n                if (currentIndex >= 0) {\n                        return currentIndex;\n                }\n\n                currentIndex = 0;\n                let object = parentNode.firstChild;\n\n                if (parentNode.childIndexCachedUpTo) {\n                        const cachedUpToNode = this._node(parentNode.childIndexCachedUpTo);\n                        object = cachedUpToNode.nextSibling;\n                        currentIndex = cachedUpToNode.getCachedIndex(parentNode) + 1;\n                }\n\n                while (object) {\n                        const node = this._node(object);\n                        node.setCachedIndex(parentNode, currentIndex);\n\n                        if (object === child) {\n                                break;\n                        }\n\n                        ++currentIndex;\n                        object = node.nextSibling;\n                }\n\n                parentNode.childIndexCachedUpTo = child;\n\n                return currentIndex;\n        }\n\n        /**\n         * Calculate the number of children.\n         *\n         * * `O(n)` where `n` is the amount of children\n         * * `O(1)` (amortized, if the tree is not modified)\n         *\n         * @method childrenCount\n         * @memberOf module:symbol-tree#\n         * @param {Object} parent\n         * @return {Number}\n         */\n        childrenCount(parent) {\n                const parentNode = this._node(parent);\n\n                if (!parentNode.lastChild) {\n                        return 0;\n                }\n\n                return this.index(parentNode.lastChild) + 1;\n        }\n\n        /**\n         * Compare the position of an object relative to another object. A bit set is returned:\n         *\n         * <ul>\n         *     <li>DISCONNECTED : 1</li>\n         *     <li>PRECEDING : 2</li>\n         *     <li>FOLLOWING : 4</li>\n         *     <li>CONTAINS : 8</li>\n         *     <li>CONTAINED_BY : 16</li>\n         * </ul>\n         *\n         * The semantics are the same as compareDocumentPosition in DOM, with the exception that\n         * DISCONNECTED never occurs with any other bit.\n         *\n         * where `n` and `m` are the amount of ancestors of `left` and `right`;\n         * where `o` is the amount of children of the lowest common ancestor of `left` and `right`:\n         *\n         * * `O(n + m + o)` (worst case)\n         * * `O(n + m)` (amortized, if the tree is not modified)\n         *\n         * @method compareTreePosition\n         * @memberOf module:symbol-tree#\n         * @param {Object} left\n         * @param {Object} right\n         * @return {Number}\n         */\n        compareTreePosition(left, right) {\n                // In DOM terms:\n                // left = reference / context object\n                // right = other\n\n                if (left === right) {\n                        return 0;\n                }\n\n                /* jshint -W016 */\n\n                const leftAncestors = []; { // inclusive\n                        let leftAncestor = left;\n\n                        while (leftAncestor) {\n                                if (leftAncestor === right) {\n                                        return TreePosition.CONTAINS | TreePosition.PRECEDING;\n                                        // other is ancestor of reference\n                                }\n\n                                leftAncestors.push(leftAncestor);\n                                leftAncestor = this.parent(leftAncestor);\n                        }\n                }\n\n\n                const rightAncestors = []; {\n                        let rightAncestor = right;\n\n                        while (rightAncestor) {\n                                if (rightAncestor === left) {\n                                        return TreePosition.CONTAINED_BY | TreePosition.FOLLOWING;\n                                }\n\n                                rightAncestors.push(rightAncestor);\n                                rightAncestor = this.parent(rightAncestor);\n                        }\n                }\n\n\n                const root = reverseArrayIndex(leftAncestors, 0);\n\n                if (!root || root !== reverseArrayIndex(rightAncestors, 0)) {\n                        // note: unlike DOM, preceding / following is not set here\n                        return TreePosition.DISCONNECTED;\n                }\n\n                // find the lowest common ancestor\n                let commonAncestorIndex = 0;\n                const ancestorsMinLength = Math.min(leftAncestors.length, rightAncestors.length);\n\n                for (let i = 0; i < ancestorsMinLength; ++i) {\n                        const leftAncestor  = reverseArrayIndex(leftAncestors, i);\n                        const rightAncestor = reverseArrayIndex(rightAncestors, i);\n\n                        if (leftAncestor !== rightAncestor) {\n                                break;\n                        }\n\n                        commonAncestorIndex = i;\n                }\n\n                // indexes within the common ancestor\n                const leftIndex  = this.index(reverseArrayIndex(leftAncestors, commonAncestorIndex + 1));\n                const rightIndex = this.index(reverseArrayIndex(rightAncestors, commonAncestorIndex + 1));\n\n                return rightIndex < leftIndex\n                        ? TreePosition.PRECEDING\n                        : TreePosition.FOLLOWING;\n        }\n\n        /**\n         * Remove the object from this tree.\n         * Has no effect if already removed.\n         *\n         * * `O(1)`\n         *\n         * @method remove\n         * @memberOf module:symbol-tree#\n         * @param {Object} removeObject\n         * @return {Object} removeObject\n         */\n        remove(removeObject) {\n                const removeNode = this._node(removeObject);\n                const parentNode = this._node(removeNode.parent);\n                const prevNode = this._node(removeNode.previousSibling);\n                const nextNode = this._node(removeNode.nextSibling);\n\n                if (parentNode) {\n                        if (parentNode.firstChild === removeObject) {\n                                parentNode.firstChild = removeNode.nextSibling;\n                        }\n\n                        if (parentNode.lastChild === removeObject) {\n                                parentNode.lastChild = removeNode.previousSibling;\n                        }\n                }\n\n                if (prevNode) {\n                        prevNode.nextSibling = removeNode.nextSibling;\n                }\n\n                if (nextNode) {\n                        nextNode.previousSibling = removeNode.previousSibling;\n                }\n\n                removeNode.parent = null;\n                removeNode.previousSibling = null;\n                removeNode.nextSibling = null;\n                removeNode.cachedIndex = -1;\n                removeNode.cachedIndexVersion = NaN;\n\n                if (parentNode) {\n                        parentNode.childrenChanged();\n                }\n\n                return removeObject;\n        }\n\n        /**\n         * Insert the given object before the reference object.\n         * `newObject` is now the previous sibling of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method insertBefore\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */\n        insertBefore(referenceObject, newObject) {\n                const referenceNode = this._node(referenceObject);\n                const prevNode = this._node(referenceNode.previousSibling);\n                const newNode = this._node(newObject);\n                const parentNode = this._node(referenceNode.parent);\n\n                if (newNode.isAttached) {\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\n                }\n\n                newNode.parent = referenceNode.parent;\n                newNode.previousSibling = referenceNode.previousSibling;\n                newNode.nextSibling = referenceObject;\n                referenceNode.previousSibling = newObject;\n\n                if (prevNode) {\n                        prevNode.nextSibling = newObject;\n                }\n\n                if (parentNode && parentNode.firstChild === referenceObject) {\n                        parentNode.firstChild = newObject;\n                }\n\n                if (parentNode) {\n                        parentNode.childrenChanged();\n                }\n\n                return newObject;\n        }\n\n        /**\n         * Insert the given object after the reference object.\n         * `newObject` is now the next sibling of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method insertAfter\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */\n        insertAfter(referenceObject, newObject) {\n                const referenceNode = this._node(referenceObject);\n                const nextNode = this._node(referenceNode.nextSibling);\n                const newNode = this._node(newObject);\n                const parentNode = this._node(referenceNode.parent);\n\n                if (newNode.isAttached) {\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\n                }\n\n                newNode.parent = referenceNode.parent;\n                newNode.previousSibling = referenceObject;\n                newNode.nextSibling = referenceNode.nextSibling;\n                referenceNode.nextSibling = newObject;\n\n                if (nextNode) {\n                        nextNode.previousSibling = newObject;\n                }\n\n                if (parentNode && parentNode.lastChild === referenceObject) {\n                        parentNode.lastChild = newObject;\n                }\n\n                if (parentNode) {\n                        parentNode.childrenChanged();\n                }\n\n                return newObject;\n        }\n\n        /**\n         * Insert the given object as the first child of the given reference object.\n         * `newObject` is now the first child of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method prependChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */\n        prependChild(referenceObject, newObject) {\n                const referenceNode = this._node(referenceObject);\n                const newNode = this._node(newObject);\n\n                if (newNode.isAttached) {\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\n                }\n\n                if (referenceNode.hasChildren) {\n                        this.insertBefore(referenceNode.firstChild, newObject);\n                }\n                else {\n                        newNode.parent = referenceObject;\n                        referenceNode.firstChild = newObject;\n                        referenceNode.lastChild = newObject;\n                        referenceNode.childrenChanged();\n                }\n\n                return newObject;\n        }\n\n        /**\n         * Insert the given object as the last child of the given reference object.\n         * `newObject` is now the last child of `referenceObject`.\n         *\n         * * `O(1)`\n         *\n         * @method appendChild\n         * @memberOf module:symbol-tree#\n         * @param {Object} referenceObject\n         * @param {Object} newObject\n         * @throws {Error} If the newObject is already present in this SymbolTree\n         * @return {Object} newObject\n         */\n        appendChild(referenceObject, newObject) {\n                const referenceNode = this._node(referenceObject);\n                const newNode = this._node(newObject);\n\n                if (newNode.isAttached) {\n                        throw Error('Given object is already present in this SymbolTree, remove it first');\n                }\n\n                if (referenceNode.hasChildren) {\n                        this.insertAfter(referenceNode.lastChild, newObject);\n                }\n                else {\n                        newNode.parent = referenceObject;\n                        referenceNode.firstChild = newObject;\n                        referenceNode.lastChild = newObject;\n                        referenceNode.childrenChanged();\n                }\n\n                return newObject;\n        }\n}\n\nmodule.exports = SymbolTree;\nSymbolTree.TreePosition = TreePosition;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ltYm9sLXRyZWUvbGliL1N5bWJvbFRyZWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLG1CQUFPLENBQUMsZ0ZBQWtCO0FBQ2pELHFCQUFxQixtQkFBTyxDQUFDLDRFQUFnQjtBQUM3QyxxQkFBcUIsbUJBQU8sQ0FBQyw0RUFBZ0I7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFVBQVU7QUFDN0IsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFVBQVU7QUFDN0IsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFVBQVU7QUFDN0IsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVc7QUFDcEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixTQUFTO0FBQzVCLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFNBQVM7QUFDNUIsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0Isb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JldmVpbGxlcnN0dWRpb3MvLi9ub2RlX21vZHVsZXMvc3ltYm9sLXRyZWUvbGliL1N5bWJvbFRyZWUuanM/NGRkYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG1vZHVsZSBzeW1ib2wtdHJlZVxuICogQGF1dGhvciBKb3JpcyB2YW4gZGVyIFdlbCA8am9yaXNAam9yaXN2YW5kZXJ3ZWwuY29tPlxuICovXG5cbmNvbnN0IFN5bWJvbFRyZWVOb2RlID0gcmVxdWlyZSgnLi9TeW1ib2xUcmVlTm9kZScpO1xuY29uc3QgVHJlZVBvc2l0aW9uID0gcmVxdWlyZSgnLi9UcmVlUG9zaXRpb24nKTtcbmNvbnN0IFRyZWVJdGVyYXRvciA9IHJlcXVpcmUoJy4vVHJlZUl0ZXJhdG9yJyk7XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlQXJyYXlJbmRleChhcnJheSwgcmV2ZXJzZUluZGV4KSB7XG4gICAgICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxIC0gcmV2ZXJzZUluZGV4XTsgLy8gbm8gbmVlZCB0byBjaGVjayBgaW5kZXggPj0gMGBcbn1cblxuY2xhc3MgU3ltYm9sVHJlZSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAYWxpYXMgbW9kdWxlOnN5bWJvbC10cmVlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGVzY3JpcHRpb249J1N5bWJvbFRyZWUgZGF0YSddIERlc2NyaXB0aW9uIHVzZWQgZm9yIHRoZSBTeW1ib2xcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zeW1ib2wgPSBTeW1ib2woZGVzY3JpcHRpb24gfHwgJ1N5bWJvbFRyZWUgZGF0YScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdSBjYW4gdXNlIHRoaXMgZnVuY3Rpb24gdG8gKG9wdGlvbmFsbHkpIGluaXRpYWxpemUgYW4gb2JqZWN0IHJpZ2h0IGFmdGVyIGl0cyBjcmVhdGlvbixcbiAgICAgICAgICogdG8gdGFrZSBhZHZhbnRhZ2Ugb2YgVjgncyBmYXN0IHByb3BlcnRpZXMuIEFsc28gdXNlZnVsIGlmIHlvdSB3b3VsZCBsaWtlIHRvXG4gICAgICAgICAqIGZyZWV6ZSB5b3VyIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogYE8oMSlgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQGFsaWFzIG1vZHVsZTpzeW1ib2wtdHJlZSNpbml0aWFsaXplXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemUob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZShvYmplY3QpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9ub2RlKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gb2JqZWN0W3RoaXMuc3ltYm9sXTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKG9iamVjdFt0aGlzLnN5bWJvbF0gPSBuZXcgU3ltYm9sVHJlZU5vZGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdCBoYXMgYW55IGNoaWxkcmVuLiBPdGhlcndpc2UgaXQgcmV0dXJucyBgZmFsc2VgLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGhhc0NoaWxkcmVuXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGhhc0NoaWxkcmVuKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlKG9iamVjdCkuaGFzQ2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIGdpdmVuIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBmaXJzdENoaWxkXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgZmlyc3RDaGlsZChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZShvYmplY3QpLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbGFzdCBjaGlsZCBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGxhc3RDaGlsZFxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGxhc3RDaGlsZChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZShvYmplY3QpLmxhc3RDaGlsZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJldmlvdXNTaWJsaW5nXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgcHJldmlvdXNTaWJsaW5nKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlKG9iamVjdCkucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG5leHQgc2libGluZyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIG5leHRTaWJsaW5nXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbmV4dFNpYmxpbmcob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGUob2JqZWN0KS5uZXh0U2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIHBhcmVudCBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHBhcmVudFxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHBhcmVudChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZShvYmplY3QpLnBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSBpbmNsdXNpdmUgZGVzY2VuZGFudCB0aGF0IGlzIGxhc3QgaW4gdHJlZSBvcmRlciBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKG4pYCAod29yc3QgY2FzZSkgd2hlcmUgYG5gIGlzIHRoZSBkZXB0aCBvZiB0aGUgc3VidHJlZSBvZiBgb2JqZWN0YFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGxhc3RJbmNsdXNpdmVEZXNjZW5kYW50XG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbGFzdEluY2x1c2l2ZURlc2NlbmRhbnQob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RDaGlsZDtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudCA9IG9iamVjdDtcblxuICAgICAgICAgICAgICAgIHdoaWxlICgobGFzdENoaWxkID0gdGhpcy5fbm9kZShjdXJyZW50KS5sYXN0Q2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbGFzdENoaWxkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgdGhlIHByZWNlZGluZyBvYmplY3QgKEEpIG9mIHRoZSBnaXZlbiBvYmplY3QgKEIpLlxuICAgICAgICAgKiBBbiBvYmplY3QgQSBpcyBwcmVjZWRpbmcgYW4gb2JqZWN0IEIgaWYgQSBhbmQgQiBhcmUgaW4gdGhlIHNhbWUgdHJlZVxuICAgICAgICAgKiBhbmQgQSBjb21lcyBiZWZvcmUgQiBpbiB0cmVlIG9yZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKG4pYCAod29yc3QgY2FzZSlcbiAgICAgICAgICogKiBgTygxKWAgKGFtb3J0aXplZCB3aGVuIHdhbGtpbmcgdGhlIGVudGlyZSB0cmVlKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByZWNlZGluZ1xuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnJvb3RdIElmIHNldCwgYHJvb3RgIG11c3QgYmUgYW4gaW5jbHVzaXZlIGFuY2VzdG9yXG4gICAgICAgICAqICAgICAgICBvZiB0aGUgcmV0dXJuIHZhbHVlIChvciBlbHNlIG51bGwgaXMgcmV0dXJuZWQpLiBUaGlzIGNoZWNrIF9hc3N1bWVzX1xuICAgICAgICAgKiAgICAgICAgdGhhdCBgcm9vdGAgaXMgYWxzbyBhbiBpbmNsdXNpdmUgYW5jZXN0b3Igb2YgdGhlIGdpdmVuIGBvYmplY3RgXG4gICAgICAgICAqIEByZXR1cm4gez9PYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjZWRpbmcob2JqZWN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJlZVJvb3QgPSBvcHRpb25zICYmIG9wdGlvbnMucm9vdDtcblxuICAgICAgICAgICAgICAgIGlmIChvYmplY3QgPT09IHRyZWVSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSB0aGlzLl9ub2RlKG9iamVjdCkucHJldmlvdXNTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU2libGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdEluY2x1c2l2ZURlc2NlbmRhbnQocHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBwcmV2aW91cyBzaWJsaW5nIHJldHVybiB0aGUgcGFyZW50IChtaWdodCBiZSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlKG9iamVjdCkucGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmQgdGhlIGZvbGxvd2luZyBvYmplY3QgKEEpIG9mIHRoZSBnaXZlbiBvYmplY3QgKEIpLlxuICAgICAgICAgKiBBbiBvYmplY3QgQSBpcyBmb2xsb3dpbmcgYW4gb2JqZWN0IEIgaWYgQSBhbmQgQiBhcmUgaW4gdGhlIHNhbWUgdHJlZVxuICAgICAgICAgKiBhbmQgQSBjb21lcyBhZnRlciBCIGluIHRyZWUgb3JkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8obilgICh3b3JzdCBjYXNlKSB3aGVyZSBgbmAgaXMgdGhlIGFtb3VudCBvZiBvYmplY3RzIGluIHRoZSBlbnRpcmUgdHJlZVxuICAgICAgICAgKiAqIGBPKDEpYCAoYW1vcnRpemVkIHdoZW4gd2Fsa2luZyB0aGUgZW50aXJlIHRyZWUpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgZm9sbG93aW5nXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7IU9iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnJvb3RdIElmIHNldCwgYHJvb3RgIG11c3QgYmUgYW4gaW5jbHVzaXZlIGFuY2VzdG9yXG4gICAgICAgICAqICAgICAgICBvZiB0aGUgcmV0dXJuIHZhbHVlIChvciBlbHNlIG51bGwgaXMgcmV0dXJuZWQpLiBUaGlzIGNoZWNrIF9hc3N1bWVzX1xuICAgICAgICAgKiAgICAgICAgdGhhdCBgcm9vdGAgaXMgYWxzbyBhbiBpbmNsdXNpdmUgYW5jZXN0b3Igb2YgdGhlIGdpdmVuIGBvYmplY3RgXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcENoaWxkcmVuPWZhbHNlXSBJZiBzZXQsIGlnbm9yZSB0aGUgY2hpbGRyZW4gb2YgYG9iamVjdGBcbiAgICAgICAgICogQHJldHVybiB7P09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGZvbGxvd2luZyhvYmplY3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmVlUm9vdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5yb290O1xuICAgICAgICAgICAgICAgIGNvbnN0IHNraXBDaGlsZHJlbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwQ2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gIXNraXBDaGlsZHJlbiAmJiB0aGlzLl9ub2RlKG9iamVjdCkuZmlyc3RDaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChmaXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudCA9IG9iamVjdDtcblxuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSB0cmVlUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSB0aGlzLl9ub2RlKGN1cnJlbnQpLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5fbm9kZShjdXJyZW50KS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoY3VycmVudCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmQgYWxsIGNoaWxkcmVuIG9mIHRoZSBnaXZlbiBvYmplY3QgdG8gYW4gYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8obilgIHdoZXJlIGBuYCBpcyB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIG9mIHRoZSBnaXZlbiBgcGFyZW50YFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGNoaWxkcmVuVG9BcnJheVxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3RbXX0gW29wdGlvbnMuYXJyYXk9W11dXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmZpbHRlcl0gRnVuY3Rpb24gdG8gdGVzdCBlYWNoIG9iamVjdCBiZWZvcmUgaXQgaXMgYWRkZWQgdG8gdGhlIGFycmF5LlxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbnZva2VkIHdpdGggYXJndW1lbnRzIChvYmplY3QpLiBTaG91bGQgcmV0dXJuIGB0cnVlYCBpZiBhbiBvYmplY3RcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdG8gYmUgaW5jbHVkZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMudGhpc0FyZ10gVmFsdWUgdG8gdXNlIGFzIGB0aGlzYCB3aGVuIGV4ZWN1dGluZyBgZmlsdGVyYC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlblRvQXJyYXkocGFyZW50LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXkgICA9IChvcHRpb25zICYmIG9wdGlvbnMuYXJyYXkpIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciAgPSAob3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcikgfHwgcmV0dXJuVHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aGlzQXJnID0gKG9wdGlvbnMgJiYgb3B0aW9ucy50aGlzQXJnKSB8fCB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gdGhpcy5fbm9kZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGxldCBvYmplY3QgPSBwYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2RlKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldENhY2hlZEluZGV4KHBhcmVudE5vZGUsIGluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlci5jYWxsKHRoaXNBcmcsIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaChvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kIGFsbCBpbmNsdXNpdmUgYW5jZXN0b3JzIG9mIHRoZSBnaXZlbiBvYmplY3QgdG8gYW4gYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8obilgIHdoZXJlIGBuYCBpcyB0aGUgYW1vdW50IG9mIGFuY2VzdG9ycyBvZiB0aGUgZ2l2ZW4gYG9iamVjdGBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBhbmNlc3RvcnNUb0FycmF5XG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBbb3B0aW9ucy5hcnJheT1bXV1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZmlsdGVyXSBGdW5jdGlvbiB0byB0ZXN0IGVhY2ggb2JqZWN0IGJlZm9yZSBpdCBpcyBhZGRlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIEludm9rZWQgd2l0aCBhcmd1bWVudHMgKG9iamVjdCkuIFNob3VsZCByZXR1cm4gYHRydWVgIGlmIGFuIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB0byBiZSBpbmNsdWRlZC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy50aGlzQXJnXSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBmaWx0ZXJgLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAgICAgICAgICovXG4gICAgICAgIGFuY2VzdG9yc1RvQXJyYXkob2JqZWN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXkgICA9IChvcHRpb25zICYmIG9wdGlvbnMuYXJyYXkpIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciAgPSAob3B0aW9ucyAmJiBvcHRpb25zLmZpbHRlcikgfHwgcmV0dXJuVHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aGlzQXJnID0gKG9wdGlvbnMgJiYgb3B0aW9ucy50aGlzQXJnKSB8fCB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICBsZXQgYW5jZXN0b3IgPSBvYmplY3Q7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIuY2FsbCh0aGlzQXJnLCBhbmNlc3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaChhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvciA9IHRoaXMuX25vZGUoYW5jZXN0b3IpLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwZW5kIGFsbCBkZXNjZW5kYW50cyBvZiB0aGUgZ2l2ZW4gb2JqZWN0IHRvIGFuIGFycmF5IChpbiB0cmVlIG9yZGVyKS5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTyhuKWAgd2hlcmUgYG5gIGlzIHRoZSBhbW91bnQgb2Ygb2JqZWN0cyBpbiB0aGUgc3ViLXRyZWUgb2YgdGhlIGdpdmVuIGBvYmplY3RgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgdHJlZVRvQXJyYXlcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJvb3RcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBbb3B0aW9ucy5hcnJheT1bXV1cbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZmlsdGVyXSBGdW5jdGlvbiB0byB0ZXN0IGVhY2ggb2JqZWN0IGJlZm9yZSBpdCBpcyBhZGRlZCB0byB0aGUgYXJyYXkuXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIEludm9rZWQgd2l0aCBhcmd1bWVudHMgKG9iamVjdCkuIFNob3VsZCByZXR1cm4gYHRydWVgIGlmIGFuIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB0byBiZSBpbmNsdWRlZC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy50aGlzQXJnXSBWYWx1ZSB0byB1c2UgYXMgYHRoaXNgIHdoZW4gZXhlY3V0aW5nIGBmaWx0ZXJgLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRyZWVUb0FycmF5KHJvb3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheSAgID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5hcnJheSkgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyICA9IChvcHRpb25zICYmIG9wdGlvbnMuZmlsdGVyKSB8fCByZXR1cm5UcnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNBcmcgPSAob3B0aW9ucyAmJiBvcHRpb25zLnRoaXNBcmcpIHx8IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIGxldCBvYmplY3QgPSByb290O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlci5jYWxsKHRoaXNBcmcsIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaChvYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gdGhpcy5mb2xsb3dpbmcob2JqZWN0LCB7cm9vdDogcm9vdH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlIG92ZXIgYWxsIGNoaWxkcmVuIG9mIHRoZSBnaXZlbiBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWAgZm9yIGEgc2luZ2xlIGl0ZXJhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGNoaWxkcmVuSXRlcmF0b3JcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmV2ZXJzZT1mYWxzZV1cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBpdGVyYWJsZSBpdGVyYXRvciAoRVM2KVxuICAgICAgICAgKi9cbiAgICAgICAgY2hpbGRyZW5JdGVyYXRvcihwYXJlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXZlcnNlID0gb3B0aW9ucyAmJiBvcHRpb25zLnJldmVyc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHRoaXMuX25vZGUocGFyZW50KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZUl0ZXJhdG9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2UgPyBwYXJlbnROb2RlLmxhc3RDaGlsZCA6IHBhcmVudE5vZGUuZmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2UgPyBUcmVlSXRlcmF0b3IuUFJFViA6IFRyZWVJdGVyYXRvci5ORVhUXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSBwcmV2aW91cyBzaWJsaW5ncyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LiAoaW4gcmV2ZXJzZSB0cmVlIG9yZGVyKVxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYCBmb3IgYSBzaW5nbGUgaXRlcmF0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcHJldmlvdXNTaWJsaW5nc0l0ZXJhdG9yXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBpdGVyYWJsZSBpdGVyYXRvciAoRVM2KVxuICAgICAgICAgKi9cbiAgICAgICAgcHJldmlvdXNTaWJsaW5nc0l0ZXJhdG9yKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZUl0ZXJhdG9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25vZGUob2JqZWN0KS5wcmV2aW91c1NpYmxpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBUcmVlSXRlcmF0b3IuUFJFVlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgbmV4dCBzaWJsaW5ncyBvZiB0aGUgZ2l2ZW4gb2JqZWN0LiAoaW4gdHJlZSBvcmRlcilcbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWAgZm9yIGEgc2luZ2xlIGl0ZXJhdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIG5leHRTaWJsaW5nc0l0ZXJhdG9yXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBpdGVyYWJsZSBpdGVyYXRvciAoRVM2KVxuICAgICAgICAgKi9cbiAgICAgICAgbmV4dFNpYmxpbmdzSXRlcmF0b3Iob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlSXRlcmF0b3IoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm9kZShvYmplY3QpLm5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgVHJlZUl0ZXJhdG9yLk5FWFRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgb3ZlciBhbGwgaW5jbHVzaXZlIGFuY2VzdG9ycyBvZiB0aGUgZ2l2ZW4gb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgIGZvciBhIHNpbmdsZSBpdGVyYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBhbmNlc3RvcnNJdGVyYXRvclxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gaXRlcmFibGUgaXRlcmF0b3IgKEVTNilcbiAgICAgICAgICovXG4gICAgICAgIGFuY2VzdG9yc0l0ZXJhdG9yKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZUl0ZXJhdG9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFRyZWVJdGVyYXRvci5QQVJFTlRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgb3ZlciBhbGwgZGVzY2VuZGFudHMgb2YgdGhlIGdpdmVuIG9iamVjdCAoaW4gdHJlZSBvcmRlcikuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdoZXJlIGBuYCBpcyB0aGUgYW1vdW50IG9mIG9iamVjdHMgaW4gdGhlIHN1Yi10cmVlIG9mIHRoZSBnaXZlbiBgcm9vdGA6XG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8obilgICh3b3JzdCBjYXNlIGZvciBhIHNpbmdsZSBpdGVyYXRpb24pXG4gICAgICAgICAqICogYE8obilgIChhbW9ydGl6ZWQsIHdoZW4gY29tcGxldGluZyB0aGUgaXRlcmF0b3IpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgdHJlZUl0ZXJhdG9yXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByb290XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmV2ZXJzZT1mYWxzZV1cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBpdGVyYWJsZSBpdGVyYXRvciAoRVM2KVxuICAgICAgICAgKi9cbiAgICAgICAgdHJlZUl0ZXJhdG9yKHJvb3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXZlcnNlID0gb3B0aW9ucyAmJiBvcHRpb25zLnJldmVyc2U7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRyZWVJdGVyYXRvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZSA/IHRoaXMubGFzdEluY2x1c2l2ZURlc2NlbmRhbnQocm9vdCkgOiByb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZSA/IFRyZWVJdGVyYXRvci5QUkVDRURJTkcgOiBUcmVlSXRlcmF0b3IuRk9MTE9XSU5HXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gb2JqZWN0ICh0aGUgbnVtYmVyIG9mIHByZWNlZGluZyBzaWJsaW5ncykuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8obilgIHdoZXJlIGBuYCBpcyB0aGUgYW1vdW50IG9mIHByZWNlZGluZyBzaWJsaW5nc1xuICAgICAgICAgKiAqIGBPKDEpYCAoYW1vcnRpemVkLCBpZiB0aGUgdHJlZSBpcyBub3QgbW9kaWZpZWQpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgaW5kZXhcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNoaWxkXG4gICAgICAgICAqIEByZXR1cm4ge051bWJlcn0gVGhlIG51bWJlciBvZiBwcmVjZWRpbmcgc2libGluZ3MsIG9yIC0xIGlmIHRoZSBvYmplY3QgaGFzIG5vIHBhcmVudFxuICAgICAgICAgKi9cbiAgICAgICAgaW5kZXgoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSB0aGlzLl9ub2RlKGNoaWxkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gdGhpcy5fbm9kZShjaGlsZE5vZGUucGFyZW50KTtcblxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gcHJpbmNpcGFsLCB5b3UgY291bGQgYWxzbyBmaW5kIG91dCB0aGUgbnVtYmVyIG9mIHByZWNlZGluZyBzaWJsaW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG9iamVjdHMgdGhhdCBkbyBub3QgaGF2ZSBhIHBhcmVudC4gVGhpcyBtZXRob2QgbGltaXRzIGl0c2VsZiBvbmx5IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHRoYXQgaGF2ZSBhIHBhcmVudCBiZWNhdXNlIHRoYXQgbGV0cyB1cyBvcHRpbWl6ZSBtb3JlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50SW5kZXggPSBjaGlsZE5vZGUuZ2V0Q2FjaGVkSW5kZXgocGFyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VycmVudEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgb2JqZWN0ID0gcGFyZW50Tm9kZS5maXJzdENoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUuY2hpbGRJbmRleENhY2hlZFVwVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZFVwVG9Ob2RlID0gdGhpcy5fbm9kZShwYXJlbnROb2RlLmNoaWxkSW5kZXhDYWNoZWRVcFRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IGNhY2hlZFVwVG9Ob2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEluZGV4ID0gY2FjaGVkVXBUb05vZGUuZ2V0Q2FjaGVkSW5kZXgocGFyZW50Tm9kZSkgKyAxO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdoaWxlIChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2RlKG9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnNldENhY2hlZEluZGV4KHBhcmVudE5vZGUsIGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3QgPT09IGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICArK2N1cnJlbnRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5jaGlsZEluZGV4Q2FjaGVkVXBUbyA9IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTyhuKWAgd2hlcmUgYG5gIGlzIHRoZSBhbW91bnQgb2YgY2hpbGRyZW5cbiAgICAgICAgICogKiBgTygxKWAgKGFtb3J0aXplZCwgaWYgdGhlIHRyZWUgaXMgbm90IG1vZGlmaWVkKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIGNoaWxkcmVuQ291bnRcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudFxuICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjaGlsZHJlbkNvdW50KHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSB0aGlzLl9ub2RlKHBhcmVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudE5vZGUubGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleChwYXJlbnROb2RlLmxhc3RDaGlsZCkgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgdGhlIHBvc2l0aW9uIG9mIGFuIG9iamVjdCByZWxhdGl2ZSB0byBhbm90aGVyIG9iamVjdC4gQSBiaXQgc2V0IGlzIHJldHVybmVkOlxuICAgICAgICAgKlxuICAgICAgICAgKiA8dWw+XG4gICAgICAgICAqICAgICA8bGk+RElTQ09OTkVDVEVEIDogMTwvbGk+XG4gICAgICAgICAqICAgICA8bGk+UFJFQ0VESU5HIDogMjwvbGk+XG4gICAgICAgICAqICAgICA8bGk+Rk9MTE9XSU5HIDogNDwvbGk+XG4gICAgICAgICAqICAgICA8bGk+Q09OVEFJTlMgOiA4PC9saT5cbiAgICAgICAgICogICAgIDxsaT5DT05UQUlORURfQlkgOiAxNjwvbGk+XG4gICAgICAgICAqIDwvdWw+XG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBzZW1hbnRpY3MgYXJlIHRoZSBzYW1lIGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIGluIERPTSwgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXRcbiAgICAgICAgICogRElTQ09OTkVDVEVEIG5ldmVyIG9jY3VycyB3aXRoIGFueSBvdGhlciBiaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIHdoZXJlIGBuYCBhbmQgYG1gIGFyZSB0aGUgYW1vdW50IG9mIGFuY2VzdG9ycyBvZiBgbGVmdGAgYW5kIGByaWdodGA7XG4gICAgICAgICAqIHdoZXJlIGBvYCBpcyB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIG9mIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIGBsZWZ0YCBhbmQgYHJpZ2h0YDpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTyhuICsgbSArIG8pYCAod29yc3QgY2FzZSlcbiAgICAgICAgICogKiBgTyhuICsgbSlgIChhbW9ydGl6ZWQsIGlmIHRoZSB0cmVlIGlzIG5vdCBtb2RpZmllZClcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBjb21wYXJlVHJlZVBvc2l0aW9uXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsZWZ0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByaWdodFxuICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBjb21wYXJlVHJlZVBvc2l0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gRE9NIHRlcm1zOlxuICAgICAgICAgICAgICAgIC8vIGxlZnQgPSByZWZlcmVuY2UgLyBjb250ZXh0IG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIHJpZ2h0ID0gb3RoZXJcblxuICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyoganNoaW50IC1XMDE2ICovXG5cbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0QW5jZXN0b3JzID0gW107IHsgLy8gaW5jbHVzaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGVmdEFuY2VzdG9yID0gbGVmdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxlZnRBbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdEFuY2VzdG9yID09PSByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBUcmVlUG9zaXRpb24uQ09OVEFJTlMgfCBUcmVlUG9zaXRpb24uUFJFQ0VESU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyIGlzIGFuY2VzdG9yIG9mIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFuY2VzdG9ycy5wdXNoKGxlZnRBbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBbmNlc3RvciA9IHRoaXMucGFyZW50KGxlZnRBbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICBjb25zdCByaWdodEFuY2VzdG9ycyA9IFtdOyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHRBbmNlc3RvciA9IHJpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmlnaHRBbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHRBbmNlc3RvciA9PT0gbGVmdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBUcmVlUG9zaXRpb24uQ09OVEFJTkVEX0JZIHwgVHJlZVBvc2l0aW9uLkZPTExPV0lORztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0QW5jZXN0b3JzLnB1c2gocmlnaHRBbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0QW5jZXN0b3IgPSB0aGlzLnBhcmVudChyaWdodEFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJvb3QgPSByZXZlcnNlQXJyYXlJbmRleChsZWZ0QW5jZXN0b3JzLCAwKTtcblxuICAgICAgICAgICAgICAgIGlmICghcm9vdCB8fCByb290ICE9PSByZXZlcnNlQXJyYXlJbmRleChyaWdodEFuY2VzdG9ycywgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdGU6IHVubGlrZSBET00sIHByZWNlZGluZyAvIGZvbGxvd2luZyBpcyBub3Qgc2V0IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBUcmVlUG9zaXRpb24uRElTQ09OTkVDVEVEO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3JcbiAgICAgICAgICAgICAgICBsZXQgY29tbW9uQW5jZXN0b3JJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5jZXN0b3JzTWluTGVuZ3RoID0gTWF0aC5taW4obGVmdEFuY2VzdG9ycy5sZW5ndGgsIHJpZ2h0QW5jZXN0b3JzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2VzdG9yc01pbkxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWZ0QW5jZXN0b3IgID0gcmV2ZXJzZUFycmF5SW5kZXgobGVmdEFuY2VzdG9ycywgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByaWdodEFuY2VzdG9yID0gcmV2ZXJzZUFycmF5SW5kZXgocmlnaHRBbmNlc3RvcnMsIGkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVmdEFuY2VzdG9yICE9PSByaWdodEFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tb25BbmNlc3RvckluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpbmRleGVzIHdpdGhpbiB0aGUgY29tbW9uIGFuY2VzdG9yXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEluZGV4ICA9IHRoaXMuaW5kZXgocmV2ZXJzZUFycmF5SW5kZXgobGVmdEFuY2VzdG9ycywgY29tbW9uQW5jZXN0b3JJbmRleCArIDEpKTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodEluZGV4ID0gdGhpcy5pbmRleChyZXZlcnNlQXJyYXlJbmRleChyaWdodEFuY2VzdG9ycywgY29tbW9uQW5jZXN0b3JJbmRleCArIDEpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByaWdodEluZGV4IDwgbGVmdEluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICA/IFRyZWVQb3NpdGlvbi5QUkVDRURJTkdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogVHJlZVBvc2l0aW9uLkZPTExPV0lORztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoaXMgdHJlZS5cbiAgICAgICAgICogSGFzIG5vIGVmZmVjdCBpZiBhbHJlYWR5IHJlbW92ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6c3ltYm9sLXRyZWUjXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZW1vdmVPYmplY3RcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSByZW1vdmVPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZShyZW1vdmVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVOb2RlID0gdGhpcy5fbm9kZShyZW1vdmVPYmplY3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSB0aGlzLl9ub2RlKHJlbW92ZU5vZGUucGFyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Tm9kZSA9IHRoaXMuX25vZGUocmVtb3ZlTm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gdGhpcy5fbm9kZShyZW1vdmVOb2RlLm5leHRTaWJsaW5nKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZS5maXJzdENoaWxkID09PSByZW1vdmVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5maXJzdENoaWxkID0gcmVtb3ZlTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUubGFzdENoaWxkID09PSByZW1vdmVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5sYXN0Q2hpbGQgPSByZW1vdmVOb2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocHJldk5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZOb2RlLm5leHRTaWJsaW5nID0gcmVtb3ZlTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobmV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2RlLnByZXZpb3VzU2libGluZyA9IHJlbW92ZU5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlLnByZXZpb3VzU2libGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZS5uZXh0U2libGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTm9kZS5jYWNoZWRJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUuY2FjaGVkSW5kZXhWZXJzaW9uID0gTmFOO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW5DaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZU9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnQgdGhlIGdpdmVuIG9iamVjdCBiZWZvcmUgdGhlIHJlZmVyZW5jZSBvYmplY3QuXG4gICAgICAgICAqIGBuZXdPYmplY3RgIGlzIG5vdyB0aGUgcHJldmlvdXMgc2libGluZyBvZiBgcmVmZXJlbmNlT2JqZWN0YC5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBpbnNlcnRCZWZvcmVcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3T2JqZWN0XG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbmV3T2JqZWN0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGlzIFN5bWJvbFRyZWVcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBuZXdPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGluc2VydEJlZm9yZShyZWZlcmVuY2VPYmplY3QsIG5ld09iamVjdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZU5vZGUgPSB0aGlzLl9ub2RlKHJlZmVyZW5jZU9iamVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldk5vZGUgPSB0aGlzLl9ub2RlKHJlZmVyZW5jZU5vZGUucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlID0gdGhpcy5fbm9kZShuZXdPYmplY3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSB0aGlzLl9ub2RlKHJlZmVyZW5jZU5vZGUucGFyZW50KTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXdOb2RlLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdHaXZlbiBvYmplY3QgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoaXMgU3ltYm9sVHJlZSwgcmVtb3ZlIGl0IGZpcnN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5wYXJlbnQgPSByZWZlcmVuY2VOb2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICBuZXdOb2RlLnByZXZpb3VzU2libGluZyA9IHJlZmVyZW5jZU5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIG5ld05vZGUubmV4dFNpYmxpbmcgPSByZWZlcmVuY2VPYmplY3Q7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5wcmV2aW91c1NpYmxpbmcgPSBuZXdPYmplY3Q7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJldk5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZOb2RlLm5leHRTaWJsaW5nID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZmlyc3RDaGlsZCA9PT0gcmVmZXJlbmNlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmZpcnN0Q2hpbGQgPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW5DaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld09iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnQgdGhlIGdpdmVuIG9iamVjdCBhZnRlciB0aGUgcmVmZXJlbmNlIG9iamVjdC5cbiAgICAgICAgICogYG5ld09iamVjdGAgaXMgbm93IHRoZSBuZXh0IHNpYmxpbmcgb2YgYHJlZmVyZW5jZU9iamVjdGAuXG4gICAgICAgICAqXG4gICAgICAgICAqICogYE8oMSlgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2QgaW5zZXJ0QWZ0ZXJcbiAgICAgICAgICogQG1lbWJlck9mIG1vZHVsZTpzeW1ib2wtdHJlZSNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3T2JqZWN0XG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgbmV3T2JqZWN0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGlzIFN5bWJvbFRyZWVcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBuZXdPYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIGluc2VydEFmdGVyKHJlZmVyZW5jZU9iamVjdCwgbmV3T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlTm9kZSA9IHRoaXMuX25vZGUocmVmZXJlbmNlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IHRoaXMuX25vZGUocmVmZXJlbmNlTm9kZS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHRoaXMuX25vZGUobmV3T2JqZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gdGhpcy5fbm9kZShyZWZlcmVuY2VOb2RlLnBhcmVudCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3Tm9kZS5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignR2l2ZW4gb2JqZWN0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGlzIFN5bWJvbFRyZWUsIHJlbW92ZSBpdCBmaXJzdCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5ld05vZGUucGFyZW50ID0gcmVmZXJlbmNlTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5wcmV2aW91c1NpYmxpbmcgPSByZWZlcmVuY2VPYmplY3Q7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5uZXh0U2libGluZyA9IHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5uZXh0U2libGluZyA9IG5ld09iamVjdDtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE5vZGUucHJldmlvdXNTaWJsaW5nID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUubGFzdENoaWxkID09PSByZWZlcmVuY2VPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUubGFzdENoaWxkID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmNoaWxkcmVuQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdPYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IHRoZSBnaXZlbiBvYmplY3QgYXMgdGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBnaXZlbiByZWZlcmVuY2Ugb2JqZWN0LlxuICAgICAgICAgKiBgbmV3T2JqZWN0YCBpcyBub3cgdGhlIGZpcnN0IGNoaWxkIG9mIGByZWZlcmVuY2VPYmplY3RgLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGBPKDEpYFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWV0aG9kIHByZXBlbmRDaGlsZFxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdPYmplY3RcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBuZXdPYmplY3QgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoaXMgU3ltYm9sVHJlZVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG5ld09iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgcHJlcGVuZENoaWxkKHJlZmVyZW5jZU9iamVjdCwgbmV3T2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlTm9kZSA9IHRoaXMuX25vZGUocmVmZXJlbmNlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdOb2RlID0gdGhpcy5fbm9kZShuZXdPYmplY3QpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ld05vZGUuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0dpdmVuIG9iamVjdCBpcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhpcyBTeW1ib2xUcmVlLCByZW1vdmUgaXQgZmlyc3QnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVmZXJlbmNlTm9kZS5oYXNDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUocmVmZXJlbmNlTm9kZS5maXJzdENoaWxkLCBuZXdPYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUucGFyZW50ID0gcmVmZXJlbmNlT2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5maXJzdENoaWxkID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5sYXN0Q2hpbGQgPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlLmNoaWxkcmVuQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdPYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IHRoZSBnaXZlbiBvYmplY3QgYXMgdGhlIGxhc3QgY2hpbGQgb2YgdGhlIGdpdmVuIHJlZmVyZW5jZSBvYmplY3QuXG4gICAgICAgICAqIGBuZXdPYmplY3RgIGlzIG5vdyB0aGUgbGFzdCBjaGlsZCBvZiBgcmVmZXJlbmNlT2JqZWN0YC5cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgTygxKWBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1ldGhvZCBhcHBlbmRDaGlsZFxuICAgICAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOnN5bWJvbC10cmVlI1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBuZXdPYmplY3RcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBuZXdPYmplY3QgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoaXMgU3ltYm9sVHJlZVxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IG5ld09iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgYXBwZW5kQ2hpbGQocmVmZXJlbmNlT2JqZWN0LCBuZXdPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2VOb2RlID0gdGhpcy5fbm9kZShyZWZlcmVuY2VPYmplY3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSB0aGlzLl9ub2RlKG5ld09iamVjdCk7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3Tm9kZS5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignR2l2ZW4gb2JqZWN0IGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGlzIFN5bWJvbFRyZWUsIHJlbW92ZSBpdCBmaXJzdCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZWZlcmVuY2VOb2RlLmhhc0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydEFmdGVyKHJlZmVyZW5jZU5vZGUubGFzdENoaWxkLCBuZXdPYmplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUucGFyZW50ID0gcmVmZXJlbmNlT2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5maXJzdENoaWxkID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5sYXN0Q2hpbGQgPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlLmNoaWxkcmVuQ2hhbmdlZCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdPYmplY3Q7XG4gICAgICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2xUcmVlO1xuU3ltYm9sVHJlZS5UcmVlUG9zaXRpb24gPSBUcmVlUG9zaXRpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/symbol-tree/lib/SymbolTree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/symbol-tree/lib/SymbolTreeNode.js":
/*!********************************************************!*\
  !*** ./node_modules/symbol-tree/lib/SymbolTreeNode.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = class SymbolTreeNode {\n        constructor() {\n                this.parent = null;\n                this.previousSibling = null;\n                this.nextSibling = null;\n\n                this.firstChild = null;\n                this.lastChild = null;\n\n                /** This value is incremented anytime a children is added or removed */\n                this.childrenVersion = 0;\n                /** The last child object which has a cached index */\n                this.childIndexCachedUpTo = null;\n\n                /** This value represents the cached node index, as long as\n                 * cachedIndexVersion matches with the childrenVersion of the parent */\n                this.cachedIndex = -1;\n                this.cachedIndexVersion = NaN; // NaN is never equal to anything\n        }\n\n        get isAttached() {\n                return Boolean(this.parent || this.previousSibling || this.nextSibling);\n        }\n\n        get hasChildren() {\n                return Boolean(this.firstChild);\n        }\n\n        childrenChanged() {\n                /* jshint -W016 */\n                // integer wrap around\n                this.childrenVersion = (this.childrenVersion + 1) & 0xFFFFFFFF;\n                this.childIndexCachedUpTo = null;\n        }\n\n        getCachedIndex(parentNode) {\n                // (assumes parentNode is actually the parent)\n                if (this.cachedIndexVersion !== parentNode.childrenVersion) {\n                        this.cachedIndexVersion = NaN;\n                        // cachedIndex is no longer valid\n                        return -1;\n                }\n\n                return this.cachedIndex; // -1 if not cached\n        }\n\n        setCachedIndex(parentNode, index) {\n                // (assumes parentNode is actually the parent)\n                this.cachedIndexVersion = parentNode.childrenVersion;\n                this.cachedIndex = index;\n        }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ltYm9sLXRyZWUvbGliL1N5bWJvbFRyZWVOb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JldmVpbGxlcnN0dWRpb3MvLi9ub2RlX21vZHVsZXMvc3ltYm9sLXRyZWUvbGliL1N5bWJvbFRyZWVOb2RlLmpzP2FkZDEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFN5bWJvbFRyZWVOb2RlIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNTaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTaWJsaW5nID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RDaGlsZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2hpbGQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLyoqIFRoaXMgdmFsdWUgaXMgaW5jcmVtZW50ZWQgYW55dGltZSBhIGNoaWxkcmVuIGlzIGFkZGVkIG9yIHJlbW92ZWQgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuVmVyc2lvbiA9IDA7XG4gICAgICAgICAgICAgICAgLyoqIFRoZSBsYXN0IGNoaWxkIG9iamVjdCB3aGljaCBoYXMgYSBjYWNoZWQgaW5kZXggKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkSW5kZXhDYWNoZWRVcFRvID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8qKiBUaGlzIHZhbHVlIHJlcHJlc2VudHMgdGhlIGNhY2hlZCBub2RlIGluZGV4LCBhcyBsb25nIGFzXG4gICAgICAgICAgICAgICAgICogY2FjaGVkSW5kZXhWZXJzaW9uIG1hdGNoZXMgd2l0aCB0aGUgY2hpbGRyZW5WZXJzaW9uIG9mIHRoZSBwYXJlbnQgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRJbmRleFZlcnNpb24gPSBOYU47IC8vIE5hTiBpcyBuZXZlciBlcXVhbCB0byBhbnl0aGluZ1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0IGlzQXR0YWNoZWQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5wYXJlbnQgfHwgdGhpcy5wcmV2aW91c1NpYmxpbmcgfHwgdGhpcy5uZXh0U2libGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBnZXQgaGFzQ2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkcmVuQ2hhbmdlZCgpIHtcbiAgICAgICAgICAgICAgICAvKiBqc2hpbnQgLVcwMTYgKi9cbiAgICAgICAgICAgICAgICAvLyBpbnRlZ2VyIHdyYXAgYXJvdW5kXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblZlcnNpb24gPSAodGhpcy5jaGlsZHJlblZlcnNpb24gKyAxKSAmIDB4RkZGRkZGRkY7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZEluZGV4Q2FjaGVkVXBUbyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRDYWNoZWRJbmRleChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gKGFzc3VtZXMgcGFyZW50Tm9kZSBpcyBhY3R1YWxseSB0aGUgcGFyZW50KVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlZEluZGV4VmVyc2lvbiAhPT0gcGFyZW50Tm9kZS5jaGlsZHJlblZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkSW5kZXhWZXJzaW9uID0gTmFOO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FjaGVkSW5kZXggaXMgbm8gbG9uZ2VyIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkSW5kZXg7IC8vIC0xIGlmIG5vdCBjYWNoZWRcbiAgICAgICAgfVxuXG4gICAgICAgIHNldENhY2hlZEluZGV4KHBhcmVudE5vZGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gKGFzc3VtZXMgcGFyZW50Tm9kZSBpcyBhY3R1YWxseSB0aGUgcGFyZW50KVxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkSW5kZXhWZXJzaW9uID0gcGFyZW50Tm9kZS5jaGlsZHJlblZlcnNpb247XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZWRJbmRleCA9IGluZGV4O1xuICAgICAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/symbol-tree/lib/SymbolTreeNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/symbol-tree/lib/TreeIterator.js":
/*!******************************************************!*\
  !*** ./node_modules/symbol-tree/lib/TreeIterator.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\n\nconst TREE = Symbol();\nconst ROOT = Symbol();\nconst NEXT = Symbol();\nconst ITERATE_FUNC = Symbol();\n\nclass TreeIterator {\n        constructor(tree, root, firstResult, iterateFunction) {\n                this[TREE] = tree;\n                this[ROOT] = root;\n                this[NEXT] = firstResult;\n                this[ITERATE_FUNC] = iterateFunction;\n        }\n\n        next() {\n                const tree = this[TREE];\n                const iterateFunc = this[ITERATE_FUNC];\n                const root = this[ROOT];\n\n                if (!this[NEXT]) {\n                        return {\n                                done: true,\n                                value: root,\n                        };\n                }\n\n                const value = this[NEXT];\n\n                if (iterateFunc === 1) {\n                        this[NEXT] = tree._node(value).previousSibling;\n                }\n                else if (iterateFunc === 2) {\n                        this[NEXT] = tree._node(value).nextSibling;\n                }\n                else if (iterateFunc === 3) {\n                        this[NEXT] = tree._node(value).parent;\n                }\n                else if (iterateFunc === 4) {\n                        this[NEXT] = tree.preceding(value, {root: root});\n                }\n                else /* if (iterateFunc === 5)*/ {\n                        this[NEXT] = tree.following(value, {root: root});\n                }\n\n                return {\n                        done: false,\n                        value: value,\n                };\n        }\n}\n\nObject.defineProperty(TreeIterator.prototype, Symbol.iterator, {\n        value: function() {\n                return this;\n        },\n        writable: false,\n});\n\nTreeIterator.PREV = 1;\nTreeIterator.NEXT = 2;\nTreeIterator.PARENT = 3;\nTreeIterator.PRECEDING = 4;\nTreeIterator.FOLLOWING = 5;\n\nObject.freeze(TreeIterator);\nObject.freeze(TreeIterator.prototype);\n\nmodule.exports = TreeIterator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ltYm9sLXRyZWUvbGliL1RyZWVJdGVyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVztBQUN2RTtBQUNBO0FBQ0EsNERBQTRELFdBQVc7QUFDdkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmV2ZWlsbGVyc3R1ZGlvcy8uL25vZGVfbW9kdWxlcy9zeW1ib2wtdHJlZS9saWIvVHJlZUl0ZXJhdG9yLmpzP2ZlNTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBUUkVFID0gU3ltYm9sKCk7XG5jb25zdCBST09UID0gU3ltYm9sKCk7XG5jb25zdCBORVhUID0gU3ltYm9sKCk7XG5jb25zdCBJVEVSQVRFX0ZVTkMgPSBTeW1ib2woKTtcblxuY2xhc3MgVHJlZUl0ZXJhdG9yIHtcbiAgICAgICAgY29uc3RydWN0b3IodHJlZSwgcm9vdCwgZmlyc3RSZXN1bHQsIGl0ZXJhdGVGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXNbVFJFRV0gPSB0cmVlO1xuICAgICAgICAgICAgICAgIHRoaXNbUk9PVF0gPSByb290O1xuICAgICAgICAgICAgICAgIHRoaXNbTkVYVF0gPSBmaXJzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICB0aGlzW0lURVJBVEVfRlVOQ10gPSBpdGVyYXRlRnVuY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyZWUgPSB0aGlzW1RSRUVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZXJhdGVGdW5jID0gdGhpc1tJVEVSQVRFX0ZVTkNdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzW1JPT1RdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzW05FWFRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW05FWFRdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdGVGdW5jID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW05FWFRdID0gdHJlZS5fbm9kZSh2YWx1ZSkucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdGVyYXRlRnVuYyA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tORVhUXSA9IHRyZWUuX25vZGUodmFsdWUpLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdGVyYXRlRnVuYyA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tORVhUXSA9IHRyZWUuX25vZGUodmFsdWUpLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXRlcmF0ZUZ1bmMgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbTkVYVF0gPSB0cmVlLnByZWNlZGluZyh2YWx1ZSwge3Jvb3Q6IHJvb3R9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSAvKiBpZiAoaXRlcmF0ZUZ1bmMgPT09IDUpKi8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tORVhUXSA9IHRyZWUuZm9sbG93aW5nKHZhbHVlLCB7cm9vdDogcm9vdH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmVlSXRlcmF0b3IucHJvdG90eXBlLCBTeW1ib2wuaXRlcmF0b3IsIHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG59KTtcblxuVHJlZUl0ZXJhdG9yLlBSRVYgPSAxO1xuVHJlZUl0ZXJhdG9yLk5FWFQgPSAyO1xuVHJlZUl0ZXJhdG9yLlBBUkVOVCA9IDM7XG5UcmVlSXRlcmF0b3IuUFJFQ0VESU5HID0gNDtcblRyZWVJdGVyYXRvci5GT0xMT1dJTkcgPSA1O1xuXG5PYmplY3QuZnJlZXplKFRyZWVJdGVyYXRvcik7XG5PYmplY3QuZnJlZXplKFRyZWVJdGVyYXRvci5wcm90b3R5cGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyZWVJdGVyYXRvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/symbol-tree/lib/TreeIterator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/symbol-tree/lib/TreePosition.js":
/*!******************************************************!*\
  !*** ./node_modules/symbol-tree/lib/TreePosition.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\n\n/* eslint-disable sort-keys */\nmodule.exports = Object.freeze({\n        // same as DOM DOCUMENT_POSITION_\n        DISCONNECTED: 1,\n        PRECEDING: 2,\n        FOLLOWING: 4,\n        CONTAINS: 8,\n        CONTAINED_BY: 16,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3ltYm9sLXRyZWUvbGliL1RyZWVQb3NpdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JldmVpbGxlcnN0dWRpb3MvLi9ub2RlX21vZHVsZXMvc3ltYm9sLXRyZWUvbGliL1RyZWVQb3NpdGlvbi5qcz9mMzFhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWRpc2FibGUgc29ydC1rZXlzICovXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAvLyBzYW1lIGFzIERPTSBET0NVTUVOVF9QT1NJVElPTl9cbiAgICAgICAgRElTQ09OTkVDVEVEOiAxLFxuICAgICAgICBQUkVDRURJTkc6IDIsXG4gICAgICAgIEZPTExPV0lORzogNCxcbiAgICAgICAgQ09OVEFJTlM6IDgsXG4gICAgICAgIENPTlRBSU5FRF9CWTogMTYsXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/symbol-tree/lib/TreePosition.js\n");

/***/ })

};
;